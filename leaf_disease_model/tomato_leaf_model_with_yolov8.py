# -*- coding: utf-8 -*-
"""tomato_leaf_model_with_YOLOV8

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/ahmednasser83/tomato-leaf-model-with-yolov8.bf02da8c-e334-41d5-acf3-ec24397d552c.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20250513/auto/storage/goog4_request%26X-Goog-Date%3D20250513T174825Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D9ef02a952030d7bc43be8f8d392d1d6851d6cda5f1271e2631fa28d4e018283d11fef5fa81d2d2e0ba2f7d389036200610cdffce2433b62f066c5b4725ee2625520e78c60d382a15745c841b1b4119907b7a860110f06ccb61c73089bbe2638a86442184e8b97310c57c529e25d6d19818e4243ae7d88ee5dd2c503bf14f055db6f485c2db3f6197de2ee2833bbdd43e8e34a9133f3128d94bed07827feeffef5ed5f640f7c306eb2b645b5701eb4db50a1606e498331471785b903a7d416718156aa3101a94e67f0427c6d2b387bfeff68abf9ef4d515e75354157eb2ec5a6a63403265d93673a71146d59c366b97a76bdb6bbbd4fd50ba0d175957c06bdff7
"""

!pip install ultralytics
from ultralytics import YOLO
from IPython.display import display, Image
from IPython import display
import os
import cv2
import matplotlib.pyplot as plt

model = YOLO('yolov8n.pt')

results = model.train(
    data= '/kaggle/input/datttaaaa/data (10).yaml',  # Dataset YAML
    epochs=120,
    seed=42,
    imgsz=640,
    conf=0.5,
    batch=16,
    optimizer='AdamW',
    weight_decay=0.0005,
    patience=10,
    verbose=True
    )

validate = model.val(
    data='/kaggle/input/datttaaaa/data (10).yaml',  # Path to your dataset YAML file
    imgsz=640,                            # Image size (optional)
    batch=32                               # Batch size (optional)
)

test_images_path='/kaggle/input/tomato-leaf-disease-detection/Tomato-Leaf-Disease-63/test/images'

predictions = model.predict(
    source=test_images_path,
    conf=0.5,
    imgsz=640
)

testing = model.val(
    data='/kaggle/input/datttaaaa/data (10).yaml',  # Path to your dataset YAML file
    imgsz=640,                                       # Image size (optional)
    batch=32,                                        # Batch size (optional)
    split='test'                                     # Validate on the test split
)

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Define class_names for tomato leaf diseases
class_names = {
    0: "Healthy",
    1: "Early Blight",
    2: "Late Blight",
    3: "Leaf Mold",
    4: "Septoria Leaf Spot",
    5: "Spider Mites",
    6: "Target Spot",
    7: "Tomato Yellow Leaf Curl Virus",
    8: "Tomato Mosaic Virus",
    9: "Bacterial Spot"
}

# Dictionary to store defect counts, confidence sums, and other metrics per class
defect_data = {}
detection_results = []  # To store individual detection results for CSV export

# Total number of detections
total_detections = 0
# Sum of all confidence scores
total_confidence = 0.0

# False Positives and False Negatives for each class (if ground truth is available)
false_positives = {cid: 0 for cid in range(len(class_names))}
false_negatives = {cid: 0 for cid in range(len(class_names))}

# Iterate through predictions
for i, result in enumerate(predictions):
    print(f"\nImage {i + 1} Predictions:")
    if result.boxes is not None and len(result.boxes) > 0:
        for box in result.boxes:
            # Extract details
            class_id = int(box.cls.item())
            confidence = box.conf.item()
            coordinates = box.xyxy.tolist()
            # Use get() with default to handle unexpected class IDs
            defect_name = class_names.get(class_id, f"Unknown Class {class_id}")

            # Update defect data
            if class_id not in defect_data:
                defect_data[class_id] = {
                    "count": 0,
                    "confidence_sum": 0.0,
                    "confidence_list": [],
                    "tp": 0,  # True Positives
                    "fp": 0,  # False Positives
                    "fn": 0,  # False Negatives
                }
            defect_data[class_id]["count"] += 1
            defect_data[class_id]["confidence_sum"] += confidence
            defect_data[class_id]["confidence_list"].append(confidence)

            # Update totals
            total_detections += 1
            total_confidence += confidence

            # Print box details
            print(f" - Class: {defect_name}, Confidence: {confidence:.2f}, Coordinates: {coordinates}")

            # Append to results for CSV export
            detection_results.append({
                "Image ID": i + 1,
                "Class": defect_name,
                "Confidence": confidence,
                "Bounding Box": coordinates
            })
    else:
        print(f" - No detections.")

# Summarize results
print("\n--- Total Disease Counts, Averages, and Percentages Across All Images ---")
summary_data = []  # To hold summary for each disease class
for class_id, data in defect_data.items():
    disease_name = class_names.get(class_id, f"Unknown Class {class_id}")
    disease_count = data["count"]
    average_confidence = data["confidence_sum"] / disease_count if disease_count > 0 else 0
    percentage_share = (disease_count / total_detections) * 100 if total_detections > 0 else 0
    min_confidence = np.min(data["confidence_list"]) if data["confidence_list"] else 0
    max_confidence = np.max(data["confidence_list"]) if data["confidence_list"] else 0

    # False Positives and False Negatives (example logic)
    false_positive_count = data["fp"]
    false_negative_count = data["fn"]

    # Print disease summary
    print(f"Disease: {disease_name}")
    print(f"  Count: {disease_count}")
    print(f"  Average Confidence: {average_confidence:.2f}")
    print(f"  Confidence Range: [{min_confidence:.2f} - {max_confidence:.2f}]")
    print(f"  Percentage Share: {percentage_share:.2f}%")
    print(f"  False Positives: {false_positive_count}")
    print(f"  False Negatives: {false_negative_count}\n")

    # Append to summary data
    summary_data.append({
        "Class": disease_name,
        "Disease Count": disease_count,
        "Average Confidence": average_confidence,
        "Confidence Range": f"[{min_confidence:.2f} - {max_confidence:.2f}]",
        "Percentage Share (%)": percentage_share,
        "False Positives": false_positive_count,
        "False Negatives": false_negative_count
    })

# Overall statistics
if total_detections > 0:
    overall_average_confidence = total_confidence / total_detections
    print(f"\nOverall Total Detections: {total_detections}")
    print(f"Overall Average Confidence: {overall_average_confidence:.2f}")
else:
    print("\nNo detections made. Cannot calculate averages.")

# Save detailed detection results to CSV
detection_df = pd.DataFrame(detection_results)
detection_df.to_csv("tomato_disease_detection_results.csv", index=False)
print("\nDetailed detection results saved to 'tomato_disease_detection_results.csv'.")

# Save disease summary to CSV
summary_df = pd.DataFrame(summary_data)
summary_df.to_csv("tomato_disease_summary.csv", index=False)
print("Disease summary saved to 'tomato_disease_summary.csv'.")

# Visualize disease counts
plt.figure(figsize=(10, 6))
summary_df.set_index("Class")["Disease Count"].plot(kind="bar", color="skyblue")
plt.title("Tomato Leaf Disease Count by Class")
plt.xlabel("Disease Class")
plt.ylabel("Count")
plt.xticks(rotation=45)
plt.grid(axis="y", linestyle="--", alpha=0.7)
plt.tight_layout()
plt.show()

# Visualize percentages
plt.figure(figsize=(10, 6))
summary_df.set_index("Class")["Percentage Share (%)"].plot(kind="bar", color="orange")
plt.title("Percentage Share by Disease Class")
plt.xlabel("Disease Class")
plt.ylabel("Percentage Share (%)")
plt.xticks(rotation=45)
plt.grid(axis="y", linestyle="--", alpha=0.7)
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

for i, result in enumerate(predictions):
    # Count objects detected
    num_objects = len(result.boxes)  # Check your library for the correct attribute

    # Visualize the predictions using the default plot method
    plt.figure(figsize=(12, 12))
    plt.imshow(result.plot())  # Use the basic plot method
    plt.axis('off')  # Remove axes
    plt.title(f"Image {i + 1} - {num_objects} Objects Detected", fontsize=16, fontweight='bold')  # Add the object count in title
    plt.show()

from ultralytics import YOLO
import os

# Your class names (for reference)
class_names = {
    0: "Healthy",
    1: "Early Blight",
    2: "Late Blight",
    3: "Leaf Mold",
    4: "Septoria Leaf Spot",
    5: "Spider Mites",
    6: "Target Spot",
    7: "Tomato Yellow Leaf Curl Virus",
    8: "Tomato Mosaic Virus",
    9: "Bacterial Spot"
}

def save_yolov8_model(model, path="tomato_disease_yolov8n.pt"):
    try:
        # Save the model in PyTorch format
        model.save(path)
        print(f"YOLOv8n model saved to {path}")

        # Verify file size
        file_size = os.path.getsize(path) / (1024 * 1024)  # Size in MB
        print(f"Model file size: {file_size:.2f} MB")

        # Export to other formats (optional)
        # ONNX format for broader compatibility
        model.export(format="onnx", imgsz=[640, 640])
        onnx_path = path.replace(".pt", ".onnx")
        if os.path.exists(onnx_path):
            onnx_size = os.path.getsize(onnx_path) / (1024 * 1024)
            print(f"ONNX model saved to {onnx_path} ({onnx_size:.2f} MB)")

    except Exception as e:
        print(f"Error saving YOLOv8n model: {e}")

# Load your trained model
# Replace this with your actual model loading code
try:
    # If you have a trained model
    model = YOLO("/kaggle/working/yolov8n.pt")
except:
    # If starting fresh or loading pre-trained
    model = YOLO("yolov8n.pt")  # Load pre-trained YOLOv8n
    print("Loaded pre-trained YOLOv8n model - replace with your trained model")

# Save the model
save_yolov8_model(model)